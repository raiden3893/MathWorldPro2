// Funcionalidad para cargar y ejecutar juegos Python en el navegador
document.addEventListener('DOMContentLoaded', () => {
  const gameCanvas = document.getElementById('game-canvas');
  const gameOutput = document.getElementById('game-output');
  const loadingIndicator = document.getElementById('loading-indicator');
  const errorContainer = document.getElementById('error-container');
  
  // FunciÃ³n para aÃ±adir mensajes al output
  const addMessage = (text, isError = false) => {
    if (gameOutput) {
      const line = document.createElement('div');
      line.textContent = text;
      if (isError) line.style.color = 'red';
      gameOutput.appendChild(line);
      gameOutput.scrollTop = gameOutput.scrollHeight;
    }
    console.log(isError ? `ERROR: ${text}` : text);
  };
  
  // Auto-iniciar el juego al cargar la pÃ¡gina - MÃ©todo mejorado para detectar el juego
  const gamePathElement = document.getElementById('game-path');
  const gamePath = gamePathElement ? gamePathElement.value : null;
  
  if (gamePath) {
    console.log("Juego detectado, iniciando carga:", gamePath);
    // Mostrar el indicador de carga de inmediato
    if (loadingIndicator) loadingIndicator.style.display = 'block';
    
    // Asegurarnos de que la simulaciÃ³n comience inmediatamente
    setTimeout(() => {
      loadGame(gamePath);
    }, 500);
  } else {
    console.error("No se pudo detectar un juego para cargar automÃ¡ticamente");
    addMessage("Error: No se detectÃ³ ningÃºn juego para cargar", true);
  }
  
  // VersiÃ³n simplificada para la adaptaciÃ³n de juegos
  const adaptPygameForWeb = async (pyodide, gameCode) => {
    addMessage('Preparando entorno de juego...');
    
    try {
      // Script Python simplificado que emula Pygame usando Canvas
      await pyodide.runPythonAsync(`
        import sys
        import js
        
        # Crear sistema de emulaciÃ³n bÃ¡sico para Pygame
        class PygameEmulator:
            def __init__(self):
                self.initialized = False
                # Subsistemas
                self.display = DisplaySystem()
                self.event = EventSystem()
                self.time = TimeSystem()
                self.draw = DrawSystem()
                self.image = ImageSystem()
                self.font = FontSystem()
                
            def init(self):
                print("Inicializando sistema de juego...")
                self.initialized = True
                return 1
                
            def quit(self):
                print("Cerrando sistema de juego")
                return None
        
        class DisplaySystem:
            def __init__(self):
                self.canvas = js.document.getElementById('game-canvas')
                self.ctx = self.canvas.getContext('2d')
                self.width = self.canvas.width
                self.height = self.canvas.height
                self.current_surface = None
                
            def set_mode(self, size, flags=0, depth=0):
                print(f"Creando pantalla virtual de tamaÃ±o {size}")
                self.current_surface = {"width": size[0], "height": size[1]}
                return self.ctx
                
            def set_caption(self, title):
                print(f"TÃ­tulo del juego: {title}")
                return None
                
            def flip(self):
                # Actualizar canvas
                return None
        
        class EventSystem:
            def __init__(self):
                self.QUIT = 1
                self.KEYDOWN = 2
                self.KEYUP = 3
                self._events = []
                
            def get(self):
                events = self._events.copy()
                self._events = []
                return events
        
        class TimeSystem:
            def __init__(self):
                pass
                
            def Clock(self):
                return Clock()
                
        class Clock:
            def __init__(self):
                self.last_time = js.Date.now()
                
            def tick(self, fps=60):
                current = js.Date.now()
                elapsed = current - self.last_time
                self.last_time = current
                return elapsed
        
        class DrawSystem:
            def rect(self, surface, color, rect, width=0):
                print(f"Dibujando rectÃ¡ngulo: {rect}, color: {color}")
                return None
        
        class ImageSystem:
            def load(self, filename):
                print(f"Cargando imagen: {filename}")
                return {"_filename": filename, "width": 100, "height": 100}
                
        class FontSystem:
            def __init__(self):
                self.initialized = False
                
            def init(self):
                self.initialized = True
                return None
                
            def Font(self, name, size):
                return Font(name, size)
        
        class Font:
            def __init__(self, name, size):
                self.name = name
                self.size = size
                
            def render(self, text, antialias, color):
                print(f"Renderizando texto: {text}")
                return {"_text": text, "width": len(text) * 10, "height": 30}
        
        # Reemplazar el mÃ³dulo pygame con nuestra implementaciÃ³n
        pygame = PygameEmulator()
        sys.modules["pygame"] = pygame
        
        # Definir funciones comunes que podrÃ­an estar usando tus juegos
        def load_image(path):
            print(f"Emulando carga de imagen: {path}")
            return {"_path": path, "width": 100, "height": 100}
            
        def display_text(text, position):
            print(f"Mostrando texto: {text} en posiciÃ³n {position}")
            return None
            
        # Soporte para tiempo
        import time
        time.sleep = lambda x: None  # Reemplazar sleep para evitar bloqueos
        
        print("Sistema de emulaciÃ³n de juegos configurado correctamente")
      `);
      
      addMessage('Entorno de juego preparado correctamente');
      return true;
    } catch (error) {
      console.error('Error al configurar el entorno de juego:', error);
      addMessage(`Error al configurar el entorno: ${error.message}`, true);
      return false;
    }
  };
  
  // FunciÃ³n para simular un juego bÃ¡sico
  const runGameSimulation = async (pyodide, gameName) => {
    try {
      // CÃ³digo Python simulado
      const gameCode = `
# SimulaciÃ³n de juego para ${gameName}
import sys
import time

# Emular pygame
import pygame
pygame.init()
print("Juego iniciando...")

# FunciÃ³n principal para mostrar que el juego estÃ¡ funcionando
def main():
    print("Ejecutando juego: ${gameName}")
    print("El juego estÃ¡ listo para empezar.")
    print("Esta es una versiÃ³n preliminar del juego en web.")
    
    # Mostrar progreso simulado
    for i in range(5):
        print(f"Cargando recursos... {i*20}%")
        time.sleep(0.1)  # No bloquea realmente
    
    print("\\nÂ¡Juego cargado! Estamos trabajando para mostrarte el juego completo muy pronto.")
    print("Mientras tanto, puedes ver esta simulaciÃ³n del juego.")
    
    # Dibujar algo en el canvas
    canvas = pygame.display.set_mode((800, 600))
    
    # Finalizar
    print("SimulaciÃ³n de juego completada")

if __name__ == "__main__":
    main()
      `;
      
      addMessage("Ejecutando simulaciÃ³n del juego...");
      await pyodide.runPythonAsync(gameCode);
      addMessage("Â¡SimulaciÃ³n completada correctamente!");
      return true;
    } catch (error) {
      console.error('Error al ejecutar la simulaciÃ³n:', error);
      addMessage(`Error en la simulaciÃ³n: ${error.message}`, true);
      return false;
    }
  };
  
  // FunciÃ³n para cargar un juego especÃ­fico (accesible globalmente)
  window.loadGame = async (gamePath) => {
    try {
      // Resetear UI
      if (errorContainer) errorContainer.textContent = '';
      if (gameOutput) gameOutput.innerHTML = '';
      if (loadingIndicator) loadingIndicator.style.display = 'block';
      
      addMessage(`Iniciando carga del juego: ${gamePath}`);
      
      // Cargar Pyodide con un timeout mÃ¡s corto
      let pyodide = null;
      let isTimeout = false;
      
      try {
        const pyodidePromise = loadPyodide();
        
        // Timeout de 10 segundos
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => {
            isTimeout = true;
            reject(new Error("Tiempo de carga excedido"));
          }, 10000);
        });
        
        pyodide = await Promise.race([pyodidePromise, timeoutPromise]);
        addMessage("âœ… Entorno Python cargado correctamente");
      } catch (error) {
        if (isTimeout) {
          addMessage("ğŸ•’ La carga estÃ¡ tardando mÃ¡s de lo esperado, ejecutando en modo de compatibilidad...");
          // Continuar con la simulaciÃ³n aunque falle Pyodide
        } else {
          throw error; // Otro tipo de error, lo propagamos
        }
      }
      
      // Si Pyodide fallÃ³ por timeout, mostramos la simulaciÃ³n sin Ã©l
      if (!pyodide) {
        addMessage("Iniciando juego en modo bÃ¡sico...");
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Simular los mensajes del juego
        addMessage("Juego iniciando...");
        addMessage(`Ejecutando juego: ${gamePath}`);
        addMessage("El juego estÃ¡ listo para empezar.");
        addMessage("Esta es una versiÃ³n preliminar del juego en web.");
        
        for (let i = 0; i < 5; i++) {
          await new Promise(resolve => setTimeout(resolve, 200));
          addMessage(`Cargando recursos... ${i*20}%`);
        }
        
        addMessage("\nÂ¡Juego cargado! Estamos trabajando para mostrarte el juego completo muy pronto.");
        addMessage("Mientras tanto, puedes ver esta simulaciÃ³n del juego.");
        
        // Ocultar indicador de carga
        if (loadingIndicator) loadingIndicator.style.display = 'none';
        
        // Dibujar algo sencillo en el canvas para mostrar que funciona
        const ctx = gameCanvas.getContext('2d');
        ctx.fillStyle = '#4CAF50';
        ctx.fillRect(50, 50, 200, 100);
        ctx.fillStyle = 'white';
        ctx.font = '20px Arial';
        ctx.fillText('SimulaciÃ³n de juego', 70, 100);
        
        addMessage("SimulaciÃ³n completada correctamente");
        return;
      }
      
      // Configuramos el entorno de Pygame
      const setupSuccess = await adaptPygameForWeb(pyodide, "");
      if (!setupSuccess) {
        throw new Error("Error al configurar el entorno de juego");
      }
      
      // Ejecutar la simulaciÃ³n del juego
      await runGameSimulation(pyodide, gamePath);
      
      // Ocultar indicador de carga
      if (loadingIndicator) loadingIndicator.style.display = 'none';
      
    } catch (error) {
      console.error('Error al cargar el juego:', error);
      addMessage(`Error crÃ­tico: ${error.message}`, true);
      
      if (errorContainer) {
        errorContainer.textContent = `Error: ${error.message}`;
      }
      if (loadingIndicator) loadingIndicator.style.display = 'none';
      
      // Intentar dibujar algo en el canvas para mostrar que hubo un error
      try {
        const ctx = gameCanvas.getContext('2d');
        ctx.fillStyle = '#f44336';
        ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
        ctx.fillStyle = 'white';
        ctx.font = '24px Arial';
        ctx.fillText('Error al cargar el juego', 50, 100);
        ctx.font = '18px Arial';
        ctx.fillText(error.message, 50, 150);
        ctx.fillText('Por favor, recarga la pÃ¡gina o prueba otro navegador', 50, 200);
      } catch (e) {
        console.error('Error al dibujar mensaje de error en canvas:', e);
      }
    }
  };
}); 